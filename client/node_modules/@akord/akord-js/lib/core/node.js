"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeService = void 0;
const service_1 = require("./service");
const constants_1 = require("../constants");
const contract_1 = require("../types/contract");
class NodeService extends service_1.Service {
    constructor() {
        super(...arguments);
        this.defaultListOptions = {
            shouldDecrypt: true,
            filter: {
                status: { ne: constants_1.status.REVOKED },
                and: {
                    status: { ne: constants_1.status.DELETED }
                }
            }
        };
    }
    /**
     * @param  {string} nodeId
     * @param  {string} name new name
     * @returns Promise with corresponding transaction id
     */
    rename(nodeId, name) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromNodeId(nodeId, this.objectType);
            this.setFunction(constants_1.functions.NODE_UPDATE);
            const body = {
                name: yield this.processWriteString(name)
            };
            return this.nodeUpdate(body);
        });
    }
    /**
     * @param  {string} nodeId
     * @param  {string} [parentId] new parent folder id
     * @returns Promise with corresponding transaction id
     */
    move(nodeId, parentId, vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromNodeId(nodeId, this.objectType, vaultId);
            this.setFunction(constants_1.functions.NODE_MOVE);
            return this.nodeUpdate(null, { parentId });
        });
    }
    /**
     * @param  {string} nodeId
     * @returns Promise with corresponding transaction id
     */
    revoke(nodeId, vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromNodeId(nodeId, this.objectType, vaultId);
            this.setFunction(constants_1.functions.NODE_REVOKE);
            return this.nodeUpdate();
        });
    }
    /**
     * @param  {string} nodeId
     * @returns Promise with corresponding transaction id
     */
    restore(nodeId, vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromNodeId(nodeId, this.objectType, vaultId);
            this.setFunction(constants_1.functions.NODE_RESTORE);
            return this.nodeUpdate();
        });
    }
    /**
     * @param  {string} nodeId
     * @returns Promise with corresponding transaction id
     */
    delete(nodeId, vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromNodeId(nodeId, this.objectType, vaultId);
            this.setFunction(constants_1.functions.NODE_DELETE);
            return this.nodeUpdate();
        });
    }
    /**
     * @param  {string} nodeId
     * @returns Promise with the decrypted node
     */
    get(nodeId, vaultId, shouldDecrypt = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const nodeProto = yield this.api.getNode(nodeId, this.objectType, vaultId);
            const { isEncrypted, keys } = yield this.api.getMembershipKeys(nodeProto.vaultId);
            const node = this.nodeInstance(nodeProto, keys);
            if (isEncrypted && shouldDecrypt) {
                yield node.decrypt();
            }
            return node;
        });
    }
    /**
     * @param  {string} vaultId
     * @returns Promise with paginated nodes within given vault
     */
    list(vaultId, listOptions = this.defaultListOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.api.getNodesByVaultId(vaultId, this.objectType, listOptions.filter, listOptions.limit, listOptions.nextToken);
            const { isEncrypted, keys } = listOptions.shouldDecrypt ? yield this.api.getMembershipKeys(vaultId) : { isEncrypted: false, keys: [] };
            return {
                items: yield Promise.all(response.items
                    .map((nodeProto) => __awaiter(this, void 0, void 0, function* () {
                    const node = this.nodeInstance(nodeProto, keys);
                    if (isEncrypted) {
                        yield node.decrypt();
                    }
                    return node;
                }))),
                nextToken: response.nextToken
            };
        });
    }
    /**
     * @param  {string} vaultId
     * @returns Promise with all nodes within given vault
     */
    listAll(vaultId, listOptions = this.defaultListOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            let token = null;
            let nodeArray = [];
            do {
                const { items, nextToken } = yield this.list(vaultId, listOptions);
                nodeArray = nodeArray.concat(items);
                token = nextToken;
                listOptions.nextToken = nextToken;
                if (nextToken === "null") {
                    token = null;
                }
            } while (token);
            return nodeArray;
        });
    }
    nodeInstance(nodeProto, keys) {
        return new this.NodeType(nodeProto, keys);
    }
    setVaultContextFromNodeId(nodeId, type, vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const object = yield this.api.getNode(nodeId, type, this.vaultId);
            yield this.setVaultContext(vaultId || object.vaultId);
            this.setObject(object);
            this.setObjectId(nodeId);
            this.setObjectType(type);
        });
    }
    getTags() {
        const _super = Object.create(null, {
            getTags: { get: () => super.getTags }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const tags = yield _super.getTags.call(this);
            return tags.concat(new contract_1.Tag(constants_1.protocolTags.NODE_ID, this.objectId));
        });
    }
}
exports.NodeService = NodeService;
