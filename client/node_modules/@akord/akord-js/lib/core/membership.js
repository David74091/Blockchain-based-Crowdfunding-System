"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MembershipService = void 0;
const constants_1 = require("../constants");
const uuid_1 = require("uuid");
const crypto_1 = require("@akord/crypto");
const service_1 = require("./service");
const membership_1 = require("../types/membership");
const contract_1 = require("../types/contract");
class MembershipService extends service_1.Service {
    constructor() {
        super(...arguments);
        this.objectType = constants_1.objectType.MEMBERSHIP;
        this.defaultListOptions = {
            shouldDecrypt: true,
            filter: {
                or: [
                    { status: { eq: constants_1.status.ACCEPTED } },
                    { status: { eq: constants_1.status.PENDING } }
                ]
            }
        };
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with the decrypted membership
     */
    get(membershipId, vaultId, shouldDecrypt = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const membershipProto = yield this.api.getMembership(membershipId, vaultId);
            let membership;
            if (shouldDecrypt) {
                const { isEncrypted, keys } = yield this.api.getMembershipKeys(membershipProto.vaultId);
                membership = new membership_1.Membership(membershipProto, keys);
                if (isEncrypted) {
                    yield membership.decrypt();
                }
            }
            else {
                membership = new membership_1.Membership(membershipProto);
            }
            return membership;
        });
    }
    /**
     * @param  {string} vaultId
     * @returns Promise with paginated memberships within given vault
     */
    list(vaultId, listOptions = this.defaultListOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.api.getMembershipsByVaultId(vaultId, listOptions.filter, listOptions.limit, listOptions.nextToken);
            const { isEncrypted, keys } = listOptions.shouldDecrypt ? yield this.api.getMembershipKeys(vaultId) : { isEncrypted: false, keys: [] };
            return {
                items: yield Promise.all(response.items
                    .map((membershipProto) => __awaiter(this, void 0, void 0, function* () {
                    const membership = new membership_1.Membership(membershipProto, keys);
                    if (isEncrypted) {
                        yield membership.decrypt();
                    }
                    return membership;
                }))),
                nextToken: response.nextToken
            };
        });
    }
    /**
    * @param  {string} vaultId
    * @returns Promise with all memberships within given vault
    */
    listAll(vaultId, listOptions = this.defaultListOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            let token = null;
            let nodeArray = [];
            do {
                const { items, nextToken } = yield this.list(vaultId, listOptions);
                nodeArray = nodeArray.concat(items);
                token = nextToken;
                listOptions.nextToken = nextToken;
                if (nextToken === "null") {
                    token = null;
                }
            } while (token);
            return nodeArray;
        });
    }
    /**
     * Invite user with an Akord account
     * @param  {string} vaultId
     * @param  {string} email invitee's email
     * @param  {RoleType} role CONTRIBUTOR or VIEWER
     * @returns Promise with new membership id & corresponding transaction id
     */
    invite(vaultId, email, role) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContext(vaultId);
            this.setActionRef(constants_1.actionRefs.MEMBERSHIP_INVITE);
            this.setFunction(constants_1.functions.MEMBERSHIP_INVITE);
            const membershipId = (0, uuid_1.v4)();
            this.setObjectId(membershipId);
            const { address, publicKey } = yield this.getUserEncryptionInfo(email, yield this.wallet.getAddress());
            const keysEncrypter = new crypto_1.KeysStructureEncrypter(this.wallet, this.dataEncrypter.keys, publicKey);
            const keys = yield keysEncrypter.encryptMemberKeys([]);
            const body = {
                keys: keys.map((keyPair) => {
                    delete keyPair.publicKey;
                    return keyPair;
                })
            };
            this.tags = [new contract_1.Tag(constants_1.protocolTags.MEMBER_ADDRESS, address)]
                .concat(yield this.getTags());
            const { data, metadata } = yield this.uploadState(body);
            let input = {
                function: this.function,
                address,
                role,
                data
            };
            const txId = yield this.api.postContractTransaction(this.vaultId, input, this.tags, metadata);
            return { membershipId, transactionId: txId };
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    accept(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            const memberDetails = yield this.getProfileDetails();
            yield this.setVaultContextFromMembershipId(membershipId);
            this.setActionRef(constants_1.actionRefs.MEMBERSHIP_ACCEPT);
            const body = {
                memberDetails: yield this.processMemberDetails(memberDetails, true),
                encPublicSigningKey: yield this.processWriteString(yield this.wallet.signingPublicKey())
            };
            this.setFunction(constants_1.functions.MEMBERSHIP_ACCEPT);
            return this.nodeUpdate(body);
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    confirm(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromMembershipId(membershipId);
            this.setActionRef(constants_1.actionRefs.MEMBERSHIP_CONFIRM);
            this.setFunction(constants_1.functions.MEMBERSHIP_INVITE);
            const { address, publicKey } = yield this.getUserEncryptionInfo(this.object.email, yield this.wallet.getAddress());
            const keysEncrypter = new crypto_1.KeysStructureEncrypter(this.wallet, this.dataEncrypter.keys, publicKey);
            const keys = yield keysEncrypter.encryptMemberKeys([]);
            const body = {
                keys: keys.map((keyPair) => {
                    delete keyPair.publicKey;
                    return keyPair;
                })
            };
            this.tags = [new contract_1.Tag(constants_1.protocolTags.MEMBER_ADDRESS, address)]
                .concat(yield this.getTags());
            const { data, metadata } = yield this.uploadState(body);
            let input = {
                function: this.function,
                address,
                data,
                role: this.object.role
            };
            const txId = yield this.api.postContractTransaction(this.vaultId, input, this.tags, metadata);
            return { transactionId: txId };
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    reject(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromMembershipId(membershipId);
            this.setActionRef(constants_1.actionRefs.MEMBERSHIP_REJECT);
            this.setFunction(constants_1.functions.MEMBERSHIP_REJECT);
            return this.nodeUpdate();
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    leave(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromMembershipId(membershipId);
            this.setActionRef(constants_1.actionRefs.MEMBERSHIP_LEAVE);
            this.setFunction(constants_1.functions.MEMBERSHIP_REJECT);
            return this.nodeUpdate();
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    revoke(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromMembershipId(membershipId);
            this.setFunction(constants_1.functions.MEMBERSHIP_REVOKE);
            let data;
            if (!this.isPublic) {
                // generate a new vault key pair
                const keyPair = yield (0, crypto_1.generateKeyPair)();
                const memberships = yield this.listAll(this.vaultId, { shouldDecrypt: false, filter: this.defaultListOptions.filter });
                this.tags = yield this.getTags();
                let newMembershipStates = [];
                let newMembershipRefs = [];
                for (let member of memberships) {
                    if (member.id !== this.objectId
                        && (member.status === constants_1.status.ACCEPTED || member.status === constants_1.status.PENDING)) {
                        const { publicKey } = yield this.getUserEncryptionInfo(member.email, member.address);
                        const memberKeysEncrypter = new crypto_1.KeysStructureEncrypter(this.wallet, this.dataEncrypter.keys, publicKey);
                        const keys = [yield memberKeysEncrypter.encryptMemberKey(keyPair)];
                        const newState = yield this.mergeState({ keys });
                        const signature = yield this.signData(newState);
                        newMembershipStates.push({
                            data: newState, tags: [
                                new contract_1.Tag("Data-Type", "State"),
                                new contract_1.Tag(constants_1.protocolTags.SIGNATURE, signature),
                                new contract_1.Tag(constants_1.protocolTags.SIGNER_ADDRESS, yield this.wallet.getAddress()),
                                new contract_1.Tag(constants_1.protocolTags.VAULT_ID, this.vaultId),
                                new contract_1.Tag(constants_1.protocolTags.NODE_TYPE, this.objectType),
                                new contract_1.Tag(constants_1.protocolTags.MEMBERSHIP_ID, member.id)
                            ]
                        });
                        newMembershipRefs.push(member.id);
                    }
                }
                const ids = yield this.api.uploadData(newMembershipStates, true);
                data = [];
                newMembershipRefs.forEach((memberId, memberIndex) => {
                    data.push({ id: memberId, value: ids[memberIndex].id });
                });
            }
            const txId = yield this.api.postContractTransaction(this.vaultId, { function: this.function, data }, this.tags);
            return { transactionId: txId };
        });
    }
    /**
     * @param  {string} membershipId
     * @param  {RoleType} role CONTRIBUTOR or VIEWER
     * @returns Promise with corresponding transaction id
     */
    changeRole(membershipId, role) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromMembershipId(membershipId);
            this.setActionRef(constants_1.actionRefs.MEMBERSHIP_CHANGE_ROLE);
            this.setFunction(constants_1.functions.MEMBERSHIP_CHANGE_ROLE);
            return this.nodeUpdate(null, { role });
        });
    }
    /**
     * Invite user without an Akord account
     * @param  {string} vaultId
     * @param  {string} email invitee's email
     * @param  {string} role CONTRIBUTOR or VIEWER
     * @returns Promise with new membership id & corresponding transaction id
     */
    inviteNewUser(vaultId, email, role) {
        return __awaiter(this, void 0, void 0, function* () {
            const { id } = yield this.api.inviteNewUser(vaultId, email, role);
            return { membershipId: id };
        });
    }
    /**
     * @param  {string} membershipId
     * @returns Promise with corresponding transaction id
     */
    inviteResend(membershipId) {
        return __awaiter(this, void 0, void 0, function* () {
            const object = yield this.api.getMembership(membershipId, this.vaultId);
            this.setActionRef(constants_1.actionRefs.MEMBERSHIP_INVITE_RESEND);
            if (object.status !== constants_1.status.PENDING && object.status !== constants_1.status.INVITED) {
                throw new Error("Cannot resend the invitation for member: " + membershipId +
                    ". Found invalid status: " + object.status);
            }
            yield this.api.inviteResend(object.vaultId, membershipId);
        });
    }
    profileUpdate(membershipId, name, avatar) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setVaultContextFromMembershipId(membershipId);
            this.setActionRef(constants_1.actionRefs.MEMBERSHIP_PROFILE_UPDATE);
            const memberDetails = yield this.processMemberDetails({ name, avatar }, true);
            this.setFunction(constants_1.functions.MEMBERSHIP_UPDATE);
            return this.nodeUpdate({ memberDetails });
        });
    }
    setVaultContextFromMembershipId(membershipId, vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const membership = yield this.api.getMembership(membershipId, vaultId);
            yield this.setVaultContext(vaultId || membership.vaultId);
            this.setObject(membership);
            this.setObjectId(membershipId);
            this.setObjectType(this.objectType);
        });
    }
    getTags() {
        const _super = Object.create(null, {
            getTags: { get: () => super.getTags }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const tags = yield _super.getTags.call(this);
            return tags.concat(new contract_1.Tag(constants_1.protocolTags.MEMBERSHIP_ID, this.objectId));
        });
    }
}
exports.MembershipService = MembershipService;
;
