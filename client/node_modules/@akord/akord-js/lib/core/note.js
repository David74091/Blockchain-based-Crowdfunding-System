"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoteService = void 0;
const node_1 = require("./node");
const node_2 = require("../types/node");
const stack_1 = require("./stack");
const crypto_1 = require("@akord/crypto");
const file_1 = require("./file");
var NoteTypes;
(function (NoteTypes) {
    NoteTypes["MD"] = "text/markdown";
    NoteTypes["JSON"] = "application/json";
})(NoteTypes || (NoteTypes = {}));
class NoteService extends node_1.NodeService {
    constructor() {
        super(...arguments);
        this.stackService = new stack_1.StackService(this.wallet, this.api);
        this.objectType = node_2.nodeType.STACK;
        this.NodeType = node_2.Stack;
    }
    /**
     * @param  {string} vaultId
     * @param  {string} content note content, ex: stringified JSON
     * @param  {string} name note name
     * @param  {string} [parentId] parent folder id
     * @param  {string} [mimeType] MIME type for the note text file, default: text/markdown
     * @returns Promise with new note id & corresponding transaction id
     */
    create(vaultId, content, name, parentId, mimeType) {
        return __awaiter(this, void 0, void 0, function* () {
            const noteFile = yield (0, file_1.createFileLike)([content], name, mimeType ? mimeType : NoteTypes.MD);
            const { stackId, transactionId } = yield this.stackService.create(vaultId, noteFile, name, parentId);
            return { noteId: stackId, transactionId };
        });
    }
    /**
    * @param  {string} noteId
    * @param  {string} content note content, ex: stringified JSON
    * @param  {string} name note name
    * @param  {string} [mimeType] MIME type for the note text file, default: text/markdown
    * @returns Promise with corresponding transaction id
    */
    uploadRevision(noteId, content, name, mimeType) {
        return __awaiter(this, void 0, void 0, function* () {
            const noteFile = yield (0, file_1.createFileLike)([content], name, mimeType ? mimeType : NoteTypes.MD);
            return this.stackService.uploadRevision(noteId, noteFile);
        });
    }
    /**
     * Get note version by index, return the latest version by default
     * @param  {string} noteId
     * @param  {string} [index] note version index
     * @returns Promise with version name & data string
     */
    getVersion(noteId, index) {
        return __awaiter(this, void 0, void 0, function* () {
            const version = yield this.stackService.getVersion(noteId, index);
            return { data: (0, crypto_1.arrayToString)(version.data), name: version.name };
        });
    }
    /**
     * @param  {string} vaultId
     * @returns Promise with all notes within given vault
     */
    list(vaultId, listOptions = this.defaultListOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const stacks = yield this.stackService.list(vaultId, listOptions);
            const notes = stacks.items.filter((stack) => { var _a; return this.isValidNoteType((_a = stack.versions) === null || _a === void 0 ? void 0 : _a[stack.versions.length - 1].type); });
            return { items: notes, nextToken: stacks.nextToken };
        });
    }
    isValidNoteType(type) {
        return Object.values(NoteTypes).includes(type);
    }
}
exports.NoteService = NoteService;
;
