"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManifestService = void 0;
const node_1 = require("./node");
const node_2 = require("../types/node");
const stack_1 = require("./stack");
const folder_1 = require("./folder");
const file_1 = require("./file");
const crypto_1 = require("@akord/crypto");
const CONTENT_TYPE = "application/x.arweave-manifest+json";
const FILE_NAME = "manifest.json";
const FILE_TYPE = "application/json";
class ManifestService extends node_1.NodeService {
    constructor() {
        super(...arguments);
        this.stackService = new stack_1.StackService(this.wallet, this.api);
        this.folderService = new folder_1.FolderService(this.wallet, this.api);
        this.objectType = node_2.nodeType.STACK;
        this.NodeType = node_2.Stack;
    }
    /**
     * @param  {string} vaultId
     * @param  {JSON} manifest manifest JSON
     * @returns Promise with corresponding transaction id
     */
    generate(vaultId, manifest) {
        return __awaiter(this, void 0, void 0, function* () {
            this.stackService.fileService.contentType = CONTENT_TYPE;
            if (!manifest) {
                // TODO: generate vault manifest
                manifest = yield this.renderManifestJSON(vaultId);
                console.log(manifest);
            }
            const file = yield (0, file_1.createFileLike)([JSON.stringify(manifest)], FILE_NAME, FILE_TYPE);
            const manifestNode = yield this.get(vaultId);
            if (manifestNode) {
                // update vault manifest
                return yield this.stackService.uploadRevision(manifestNode.id, file);
            }
            else {
                // create new vault manifest
                return yield this.stackService.create(vaultId, file, file.name);
            }
        });
    }
    /**
     * @returns Promise with vault manifest node
     */
    get(vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const stacks = yield this.stackService.listAll(vaultId);
            const manifest = stacks.find((stack) => stack.name === FILE_NAME);
            return manifest;
        });
    }
    /**
     * @returns Promise with vault manifest JSON data
     */
    getVersion(vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const manifest = yield this.get(vaultId);
            if (!manifest) {
                throw new Error("A vault manifest does not exist yet. Use akord.manifest.generate(vaultId) to create it.");
            }
            const manifestFile = yield this.stackService.getVersion(manifest.id);
            return JSON.parse((0, crypto_1.arrayToString)(manifestFile.data));
        });
    }
    /**
     *
     * @returns manifest in json format
    */
    renderManifestJSON(vaultId, indexName) {
        return __awaiter(this, void 0, void 0, function* () {
            // takes a flat list of folders and stacks and generates a tree
            const treeify = (folders, stacks) => {
                // initalize our treelist with a root folder + stacks
                var treeList = [{ id: null, parentId: null, name: null, stacks: [] }];
                stacks.forEach((s) => {
                    if (!s["parentId"])
                        treeList[0]["stacks"].push(s);
                });
                // setup a lookup table
                var lookup = {};
                folders.forEach(function (obj) {
                    lookup[obj["id"]] = obj;
                    obj["children"] = [];
                    obj["stacks"] = [];
                    // add the related stacks to this folder
                    stacks.forEach((s) => {
                        if (s["parentId"] === obj["id"])
                            obj["stacks"].push(s);
                    });
                });
                // add the folders  to its parent folder (tree)
                folders.forEach((obj) => {
                    if (obj["parentId"] != null) {
                        lookup[obj["parentId"]]["children"].push(obj);
                    }
                    else {
                        treeList.push(obj);
                    }
                });
                return treeList;
            };
            // take the hierachical tree and compute the folder paths
            const computePaths = (tree, path) => {
                var paths = [];
                tree.forEach((folder) => {
                    folder['stacks'].forEach((stack) => {
                        // construct the path name
                        var pathName = [path, folder['name'], stack.name]
                            .filter((p) => p != null)
                            .join("/");
                        var arweaveId = stack.versions
                            .slice(-1)[0]
                            .resourceUri.filter((r) => {
                            if (r.split(":")[0] == "arweave")
                                return r;
                        })
                            .map((r) => r.split(":")[1])[0];
                        paths.push({
                            id: arweaveId,
                            path: pathName,
                        });
                    });
                    // process the children
                    if (folder['children']) {
                        var pathName = folder['name'];
                        if (path)
                            pathName = [path, folder['name']].join("/");
                        var children = computePaths(folder['children'], pathName);
                        paths.push(...children);
                    }
                });
                return paths;
            };
            // load and clean list of folders
            var folders = (yield this.folderService.listAll(vaultId)).map((n) => {
                const { id, parentId, name } = n;
                return { id, parentId, name };
            });
            // console.log(JSON.stringify(folders, null, 2));
            // load and clean list of stacks
            const stacks = (yield this.stackService.listAll(vaultId)).map((s) => {
                const { id, parentId, name, versions } = s;
                return { id, parentId, name, versions };
            });
            const tree = treeify(folders, stacks);
            // console.log(JSON.stringify(tree, null, 2));
            const paths = computePaths(tree, null);
            //   console.log(JSON.stringify(paths, null, 2));
            // map paths to manifest hash
            var manifest = {};
            paths.forEach((path) => {
                manifest[path.path] = { id: path.id };
            });
            return {
                manifest: "arweave/paths",
                version: "0.1.0",
                index: {
                    path: indexName || "index.html",
                },
                paths: manifest,
            };
        });
    }
    ;
}
exports.ManifestService = ManifestService;
;
